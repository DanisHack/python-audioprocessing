Things to do:

* move plotting code to a separate module to save RAM by not loading GUI
  toolkits and matplotlib
* document and clean up the library
* there is a bug in the wave module -- mono files's .getnchannels() method returns 2
* write an algorithm that combines the phase beat detector and a time-domain beat detector
  for best results, and write a program that uses it and writes the TBPM tag on mp3
* now that we know the FFT code is solid, we can perhaps apply the bark scale to get the
  appropriate buckets from the FFT, so we can compare songs
* for a song comparison plugin for Amarok, think about the database structure that will
  contain the signatures and also cached correlations between them
* make a set of command-line tools that allow to analyze and cache those results, then
  perform correlations, right from the command line, without the need for Amarok or
  programming expertise
* re-enable support for correlating less than two minutes of audio (disparity in 
  vector sizes for the input of the correlate() method)
* practice fadvise or find a way to decode an mp3 through pipes, sigpipe or stop the
  decoding as soon as it gets to a certain amount of data, read the data chunked, and
  also correctly determine sample rate (mpg321 pipe fails to do correct sample rate
  on several input songs)
* use streams to process data as fast as possible and provide a streams abstraction
  to reduce the amount of RAM required to process and to avoid temporary files
  altogether
* investigate use of float32 to reduce RAM usage during analysis.  investigate precision
  impact on correlation using float32/16 instead of float64.
* investigate appropriate methods to serialize values.  pit pickle binary against
  Google pbuffers and others.  goal: minute data size without appreciable
  precision loss, fastest correlation computing.
* investigate whether a central server provides a good performance advantage to
  offload correlations and take advantage of a huge database of correlations.  naturally
  each feature extraction sent to the server must be keyed against a unique ID
  generated by the music player itself.  investigate architecture of said server.
* reduce RAM usage by loading chunk-by-chunk instead of the whole 2 minutes in RAM
* improve performance by vectorizing processing as much as possible
